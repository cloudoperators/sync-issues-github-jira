name: 'Sync github issues to jira'
inputs:
  JIRA_URL:
    description: Jira URL domain to be stored as a secret.
    required: true
  JIRA_USERNAME:
    description: Jira username to be stored as a secret.
    required: true
  JIRA_API_TOKEN:
    description: Jira API token to be stored as a secret.
    required: true
  JIRA_COMPONENT:
    description: Jira component to be stored as a secret.
    required: true
  JIRA_PROJECT_KEY:
    description: Jira project key to be stored as a secret.
    required: true
  JIRA_EPIC_KEY:
    description: Jira epic key to be stored as a secret.
    required: true
  JIRA_ISSUE_TYPE:
    description: Jira issue type.
    required: false
    default: "Feature"
  JIRA_LINK_TYPE:
    description: Jira link type.
    required: false
    default: "Dependency"
  label:
    description: 'Label which will trigger a Jira import.'
    required: true
    default: 'jira'

runs:
  using: "composite"
  steps:
    #- name: Dump GitHub context
    #  run: echo '${{ toJSON(github) }}'
    #  shell: bash
    - name: restrict action to labelled issues and issue comments
      run: |
        set -eux

        echo "NeedsJiraUpdate=false" >> $GITHUB_ENV

        if [ ${{ github.event_name }} != "issues" ] && [ ${{ github.event_name }} != "issue_comment" ]; then
          echo "This action only work on issue events. Please use on: issues or issue_comment to use this action."
          exit 1
        fi

        if [ ${{ github.event.issue.pull_request }} ]; then
          echo "This action only work on issues, not pull requests."
          exit 0
        fi

        # Issue creation with label will trigger 2 events and run twice: one create, one labelled.
        # let just focus on labelling then for creating issues Jira-side.
        if [ ${{ github.event_name }} == "issues" ] && [ ${{ github.event.action }} == "opened" ]; then
          echo "Ignoring creation of issues as a label will trigger a second event."
          exit 0
        fi

        # We only operate on labelled issues or issues that are just unlabeled with our desired label
        ## check if one label of labels is our jira label
        toconsider=${{ contains(github.event.issue.labels.*.name, inputs.label) }}
        ## second chance, this has just been unlabeled and needs to be deleted on Jira
        if [ ${{ github.event.action }} == "unlabeled" ] && [ ${{ github.event.label.name }} == ${{ inputs.label }} ]; then
          toconsider=true
        fi
        if [ "${toconsider}" == false ]; then
          echo "Our desired label not found on issue or not unlabeled, skipping"
          exit 0
        fi

        # And finally, for the "labeled" event, we are only interested if the new added label is our desired one.
        if [ ${{ github.event.action }} == "labeled" ] && [ ${{ github.event.label.name }} != ${{ inputs.label }} ]; then
          echo "Not interested in this action, skipping"
          exit 0
        fi

        # last one wins
        echo "NeedsJiraUpdate=true" >> $GITHUB_ENV
      shell: bash

    - name: "Update jira"
      if: ${{ env.NeedsJiraUpdate == 'true' }}
      env:
        # ID is the html url to keep a link between systems as there is no way to force an ID on Jira side.
        id: ${{ github.event.issue.html_url }}
        title: ${{ github.event.issue.title }}
        body: ${{ github.event.issue.body }}
        author: ${{ github.event.issue.user.login }}
        component: ${{ inputs.component }}
        commentAuthor: ${{ github.actor }}
        comment: ${{ github.event.comment.body }}
      shell: bash
      run: |
        set -eux

        # Convert markdown to JIRA using mistletoe package which is available starting with impish.
        # Since GH runners only have LTS versions it's safe to only check for focal which doesn't have the package.
        if [ $(lsb_release -c -s) == "focal" ]; then
          echo "Converting Markdown to JIRA is only possible starting with Ubuntu 22.04 (jammy). Pushing verbatim content to JIRA..."
        else
          TMPDIR=$(mktemp -d)
          trap 'rm -rf -- "$TMPDIR"' EXIT

          sudo apt install -y python3-mistletoe
          echo ${body} > $TMPDIR/body.md
          echo ${comment} > $TMPDIR/comment.md
          body=$(PYTHONPATH=/usr/share/doc/python3-mistletoe mistletoe -r examples.jira_renderer.JIRARenderer $TMPDIR/body.md)
          comment=$(PYTHONPATH=/usr/share/doc/python3-mistletoe mistletoe -r examples.jira_renderer.JIRARenderer $TMPDIR/comment.md)
        fi

        description="${body}"
        
        echo "Creating issue ${title}} and linking it as a dependency to ${{ inputs.DEPENDENT_ISSUE}}"
        
        # Create the new issue
        create_response=$(curl -s -u "${{ inputs.JIRA_USERNAME}}:${{ inputs.JIRA_API_TOKEN}}" -X POST -H "Content-Type: application/json" --data '{
          "fields": {
            "project": {
              "key": "${{ inputs.JIRA_PROJECT_KEY }}"
            },
            "summary": "$title",
            "description": "$description",
            "issuetype": {
              "name": "${{ inputs.JIRA_ISSUE_TYPE }}"
            },
            "components": [
              {
                "name": "${{ inputs.JIRA_COMPONENT }}"
              }
            ],
            "customfield_10008": "${{ inputs.JIRA_EPIC_KEY }}"
          }
        }' "https://${{ inputs.JIRA_URL }}/rest/api/2/issue/")
        
        # Extract the new issue key from the response
        new_issue_key=$(echo $create_response | jq -r '.key')
        
        # Link the new issue to the existing issue
        curl -u "${{ inputs.JIRA_USERNAME}}:${{ inputs.JIRA_API_TOKEN}}" -X POST -H "Content-Type: application/json" --data '{
          "type": {
            "name": "${{ inputs.JIRA_LINK_TYPE }}"
          },
          "inwardIssue": {
            "key": "${{inputs.DEPENDENT_ISSUE}}"
          },
          "outwardIssue": {
            "key": "$new_issue_key"
          }
        }' "https://${{ inputs.JIRA_URL }}/rest/api/2/issueLink"
